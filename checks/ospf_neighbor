#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
#
#
###############################################################################
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################

###############################################################################
# $Id: ospf_neighbor 288 2012-07-10 11:06:38Z twollner $
# Descr: OSPF Neighbor State check_mk check
# $Author: twollner $
# $Date: 2012-07-10 13:06:38 +0200 (Tue, 10 Jul 2012) $
# $Rev: 288 $
###############################################################################
# Author: Thomas Wollner (tw@wollner-net.de)
###############################################################################
#
# changes by: thl-cmk[at]outlook[dot]com
# url       : https://thl-cmk.hopto.org
#
#  2018-06-15: changed item from neighbor id to neighbor ip
#              added events as perfdata (incl. metrics file)
#              moved part of the output to long output
#              a little code cleanup to better match coding guide lines
#  2019-11-03: moved 'events' from infotext to longoutput
#  2020-07-26: added parse section, alias, wato for alias and state
#
#
#
###############################################################################

# Example Agent Output:
# OSPF-MIB

# 1.3.6.1.2.1.14.10.1.1.172.20.2.214.0 = IpAddress: 172.20.2.214
# 1.3.6.1.2.1.14.10.1.2.172.20.2.214.0 = INTEGER: 0
# 1.3.6.1.2.1.14.10.1.3.172.20.2.214.0 = IpAddress: 192.168.1.2
# 1.3.6.1.2.1.14.10.1.4.172.20.2.214.0 = INTEGER: 2
# 1.3.6.1.2.1.14.10.1.5.172.20.2.214.0 = INTEGER: 1
# 1.3.6.1.2.1.14.10.1.6.172.20.2.214.0 = INTEGER: 8
# 1.3.6.1.2.1.14.10.1.7.172.20.2.214.0 = Counter32: 6
# 1.3.6.1.2.1.14.10.1.8.172.20.2.214.0 = Gauge32: 0
# 1.3.6.1.2.1.14.10.1.9.172.20.2.214.0 = INTEGER: 1
# 1.3.6.1.2.1.14.10.1.10.172.20.2.214.0 = INTEGER: 1
# 1.3.6.1.2.1.14.10.1.11.172.20.2.214.0 = INTEGER: 2
#
# sample parsed
# {
#  '172.17.108.52': {'helperage': '', 'prio': '1', 'permanence': 'dynamic', 'helperstatus': '', 'options': '2',
#                    'state': '8', 'hellosup': 'false', 'helperexitreason': '', 'events': 6, 'rtrid': '10.250.128.130'},
#  '172.17.108.60': {'helperage': '', 'prio': '1', 'permanence': 'dynamic', 'helperstatus': '', 'options': '2',
#                    'state': '8', 'hellosup': 'false', 'helperexitreason': '', 'events': 6, 'rtrid': '10.253.128.101'},
#  '172.17.108.58': {'helperage': '', 'prio': '1', 'permanence': 'dynamic', 'helperstatus': '', 'options': '2',
#                    'state': '8', 'hellosup': 'false', 'helperexitreason': '', 'events': 12, 'rtrid': '172.17.0.2'},
#  '172.17.108.49': {'helperage': '', 'prio': '1', 'permanence': 'dynamic', 'helperstatus': '', 'options': '2',
#                    'state': '8', 'hellosup': 'false', 'helperexitreason': '', 'events': 9, 'rtrid': '172.17.0.2'}
# }
#

factory_settings['ospf_neighbor_default_levels'] = {
}

def parse_ospf_neighbor(info):
    def ospf_nbr_hellosuppressed(st):
        names = {'1': 'true',
                 '2': 'false'}
        return names.get(st, st)

    def ospf_nbr_permanence(st):
        names = {'1': 'dynamic',
                 '2': 'permanent'}
        return names.get(st, st)

    def ospf_nbr_helperstatus(st):
        names = {'1': 'notHelping',
                 '2': 'helping'}
        return names.get(st, st)

    def ospf_nbr_helperexitreason(st):
        names = {'1': 'none',
                 '2': 'inProgress',
                 '3': 'completed',
                 '4': 'timedOut',
                 '5': 'topologyChanged'}
        return names.get(st, st)

    def ospf_nbr_options(st):
        '''
        A bit mask corresponding to the neighbor's options field.
        Bit 0, if set, indicates that the system will operate on Type of Service metrics other than TOS 0.
               If zero, the neighbor will ignore all metrics except the TOS 0 metric.
        Bit 1, if set, indicates that the associated area accepts and operates on external information;
               if zero, it is a stub area.
        Bit 2, if set, indicates that the system is capable of routing IP multicast datagrams, that is that it
               implements the multicast extensions to OSPF.
        Bit 3, if set, indicates that the associated area is an NSSA. These areas are capable of carrying type-7
               external advertisements, which are translated into type-5 external advertisements at NSSA borders.
        '''
        try:
            st = ord(st)
        except TypeError:
            return 'unknown'

        options = []
        for key, value in [
            (1, 'non TOS 0 service metrics accepted'),
            (2, 'not a stub area'),
            (4, 'IP multicast routing capable'),
            (8, 'is NSSA'),
        ]:
            if st & key == key:
                options.append(value)

        options = ', '.join(options)
        if options == '':
            return 'unknown'
        else:
            return options

    parsed = {}
    for ip, rtrid, options, prio, state, events, permanence, hellosup, helperstatus, helperage, helperexitreason in info:
        parsed[ip]={}
        parsed[ip]['rtrid'] = rtrid
        parsed[ip]['options'] = ospf_nbr_options(options)
        parsed[ip]['prio'] = prio
        parsed[ip]['state'] = state
        parsed[ip]['events'] = int(events)
        parsed[ip]['permanence'] = ospf_nbr_permanence(str(permanence))
        parsed[ip]['hellosup'] = ospf_nbr_hellosuppressed(hellosup)
        parsed[ip]['helperstatus'] = ospf_nbr_helperstatus(helperstatus)
        parsed[ip]['helperage'] = helperage
        parsed[ip]['helperexitreason'] = ospf_nbr_helperexitreason(helperexitreason)

    return parsed


def inventory_ospf_neighbor(parsed):
    for neighbor in parsed.keys():
        yield  neighbor, None


def check_ospf_neighbor(item, params, parsed):
    def ospf_nbr_state(st):
        names = {'1': 'down',
                 '2': 'attempt',
                 '3': 'init',
                 '4': 'twoWay',
                 '5': 'exchangeStart',
                 '6': 'exchange',
                 '7': 'loading',
                 '8': 'full'}
        return names.get(st, 'unknown: %s' % st)

    # default checkmk states for ctsxSxpConnStatus
    neighborstate = {
        '1': 2,  # down
        '2': 1,  # attempt
        '3': 1,  # init
        '4': 0,  # twoWay
        '5': 1,  # exchangeStart
        '6': 1,  # exchange
        '7': 1,  # loading
        '8': 0,  # full
    }

    alias = None
    notFoundState = 3

    for neighbour, neighbourAlias, neighbourNotFoundState in params.get('peer_list', []):
        if item == neighbour:
            alias = neighbourAlias
            notFoundState = neighbourNotFoundState

    if item in parsed.keys():
        neighbor = parsed[item]

        perfdata = []
        longoutput = ''

        infotext = 'Neighbor ID: %s' % neighbor['rtrid']
        if alias:
            infotext += ', Alias: %s' % alias

        neighborstate.update(params.get('neighborstate', neighborstate))  # update neighborstatus with params
        yield neighborstate.get(neighbor['state'], 3), 'Status %s' % ospf_nbr_state(neighbor['state'])

        perfdata.append(['ospf_events', neighbor['events']])

        for text, value in [
            ('\nNeighbor options', neighbor['options']),
            ('\nNeighbor priority', neighbor['prio']),
            ('\nNeighbor permanence', neighbor['permanence']),
            ('\nNeighbor hello suppressed', neighbor['hellosup']),
            ('\nNeighbor helper status', neighbor['helperstatus']),
            ('\nNeighbor helper age', neighbor['helperage']),
            ('\nNeighbor helper exit reason', neighbor['helperexitreason']),
            ]:
            if value != '':
                longoutput += '%s: %s' %(text, value)

        yield 0, infotext + longoutput, perfdata
    else:
        infotext = 'Item not found in SNMP data'
        if alias:
            infotext += ', Alias: %s' % alias
        yield notFoundState, infotext


check_info['ospf_neighbor'] = {
    'check_function'         : check_ospf_neighbor,
    'inventory_function'     : inventory_ospf_neighbor,
    'parse_function'         : parse_ospf_neighbor,
    'service_description'    : 'OSPF neighbor %s',
    'default_levels_variable': 'ospf_neighbor_default_levels',
    'has_perfdata'           : True,
    'group'                  : 'ospf_neighbor',
    'snmp_scan_function'     : lambda oid: oid('.1.3.6.1.2.1.14.10.1.1.*') != None,
    'snmp_info'              : ('.1.3.6.1.2.1.14.10.1', [
                                1,   # 'ospfNbrIpAddr'
                                3,   # 'ospfNbrRtrId'
                                4,   # 'ospfNbrOptions'
                                5,   # 'ospfNbrPriority'
                                6,   # 'ospfNbrState
                                7,   # 'ospfNbrEvents'
                                10,  # 'ospfNbrPermanence'
                                11,  # 'ospfNbrHelloSuppressed'
                                12,  # 'ospfNbrRestartHelperStatus'
                                13,  # 'ospfNbrRestartHelperAge'
                                14,  # 'ospfNbrRestartHelperExitReason'
                                ]
                                ),
 }



